== Part 1: Introduce reactive behavior in the monolith

Each of the steps to transform the application is in a separate branch in the https://github.com/OndrejM-demonstrations/ReactiveWay-cargotracker[Example project]:

 . `master` - the original source code of the Cargo Tracker project with some general improvements
 . Asynchronous API and chaining callbacks:
 .. `01_async_api_01_jaxrs_client` - enhancement of the REST client accessing the pathfinder microservice - uses async API, but the request still waits for results to update GUI. 
 .. `02_chaining_01_completablefuture` - CompletableFuture is used to chain executions when computation is completed asynchronously
 . Messaging:
 .. `03_messages_01_websocket` - added web sockets to update the UI asynchronously and make it more responsive. Web page is loaded immediately and data is pushed later when ready -> page is lot more responsive. We still have some blocking calls in the pipeline, therefore page still takes unnecessary time to load initially, or the application waits too long before sending updated to the page using the websocket.
 .. `03_messages_02_event_bus` - turned synchronous request-response call to the PathFinder component over REST API into asynchronous message passing communication. Each computed item is sent immediately as a message, without any delay. DirectCompletionStream builds upon CompletableFuture to provide means to chain callbacks over a stream of incomming messages, which is not supported by CompletableFuture itself. Incoming messages are turned into websocket messages and sent to the page, therefore the computed data can be displayed immediatelly without waiting for all data.
 .. `03_messages_03_jaxrs_sync` - refactoring of the PathFinder module so that it supports both the asynchronous message communication method as well as the original REST API. This is to show the difference between both approaches in the same code base
 . Executing blocking code on a separate thread pool
 .. `04_separate_thread_pools_01_for_DB_calls` - Blocking DB calls in ItinerarySelection.java are executing using a separate managed executor service, to avoid blocking the main executor service and listener thread pools, which are meant for non-blocking fast processing and should reserve small amount of threads to decrease unnecessary context switching
 . Context propagation
 .. `05_context_propagation_01_jaxrs_async_request` - propagation of JAX-RS request context so that the response from the PathFinder REST API can be built and completed in asynchronous callbacks in different threads if needed
 .. `05_context_propagation_02_tx` - propagation of JTA transactions to the threads that execute callbacks
 ... JTA transactions must not be container managed because they need to outlive the method call that started them
 ... JTA transactions must not be started within an EJB, because EJBs throw exception when such a transaction is not finished before its method is left
 ... TransactionManage is used to suspend a transaction before an asynchronous call and resume it in a callback